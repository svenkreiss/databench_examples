{% extends "templates/analysis.html" %}


{% block head %}
<style>
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
</style>
{% end %}


{% block analysis %}
<h3>Generic UI Elements</h3>
{% filter markdown %}
Below are the _slider_ and _button_ as generic UI elements as demonstrated in
the first part of the tutorial. They are layouted using the grid systems of
[Twitter Bootstrap 3](http://getbootstrap.com/css/#grid).
{% endfilter %}
<div class="row">
    <div class="col-md-3">
        <label for="sleep_duration">Duration of sleep</label>
        <input type="range" name="sleep_duration" min="1" max="5" step="1" value="1" />
    </div>
    <div class="col-md-9">
        <button class="btn btn-primary" data-signal-name="run">Run</button>
    </div>
</div>

<br /><br />
<h3>Matplotlib, Basic d3.js and a d3.js Plot</h3>
{% filter markdown %}
This part shows the output of the _Matplotlib_ (left) and the
_Basic d3.js_ (right) part of the tutorial. The output is generated
when you click _Run_ above.
{% endfilter %}
<div class="row">
    <div class="col-md-4">
        <div id="mpld3canvas"></div>
    </div>
    <div class="col-md-4">
        <svg id="canvas_basic" width="300" height="300" />
    </div>
    <div class="col-md-4">
        <svg id="canvas_plot" width="300" height="300" />
    </div>
</div>

<hr />
<!-- This log output below is just nice to have when starting to design an
analysis. Feel free to just delete the line below now or later. -->
<pre id="log"></pre>
{% end %}



{% block footer %}
<script>
// Initialize Databench's frontend library.
var databench = Databench();

// CHANGEME. Customize the code below.
// Initialize the VizBasic for our canvas element.
var viz_basic = VizBasic('canvas_basic');

// Listen for the 'update' signal from the backend. This is the only
// Databench specific code here.
databench.on('update_basic', function(json) {
    viz_basic(json);
});

// Implement a basic drawing with d3.js.
function VizBasic(id) {
    // Initialize the d3 selector for the svg element and
    // obtain height and width.
    var svg = d3.select('#'+id),
        height = parseFloat(svg.attr('height')),
        width = parseFloat(svg.attr('width'));

    // Return the function that is used to update the data
    // of what is plotted. The data 'json' has to be of the form:
    // [
    //     {'id': 1, 'x1': 0.1, 'y1': 0.1, 'x2': 0.8, 'y2': 0.1,
    //      'width': 0.05, 'color': 0.5},
    //     {'id': 2, 'x1': 0.1, 'y1': 0.3, 'x2': 0.8, 'y2': 0.3,
    //      'width': 0.05, 'color': 0.7},
    //     {'id': 3, 'x1': 0.1, 'y1': 0.5, 'x2': 0.8, 'y2': 0.5,
    //      'width': 0.05, 'color': 0.9},
    //     ...
    // ]
    return function(json) {
        // The new 'json' data (has to be an array) is compared to the
        // existing elements with the class 'line'. By default, d3.js
        // uses the element index in the array as the key to associate
        // elements from previous data calls with the new ones. This
        // breaks when data is inserted in the middle of arrays.
        // Therefore, a function that returns the 'key' can be specified
        // as the second argument to data(). Here, the key is the element
        // with the name 'id'.
        lines = svg.selectAll(".line").data(json, function(d) { return d.id; });

        // Specify what happens how to initialize a new element. Note
        // that lines.transition() is also applied to elements that just
        // entered. Specify the initial attributes here (like width 0.0)
        // and then set the actual attributes it should animate to in
        // transition() below.
        //
        // Every attribute is given either a value (like for stroke-width)
        // or the value is obtained by calling a function with the data
        // element, in this example it could be
        //    {'id': 1, 'x1': 0.1, 'y1': 0.1, 'x2': 0.8, 'y2': 0.1,
        //     'width': 0.05, 'color': 0.1}
        // and the function calculates the value. Below, the functions
        // scale x1, y1, x2 and y2 from a range of [0,1] to [0,width]
        // and [0,height] in pixels and convert a color in the range
        // [0,1] to a color of the form #123456 by using the d3.hsl()
        // function.
        lines.enter()
            .append("svg:line")
            .attr("class", "line")
            .attr("x1", function(d) { return width*d.x1; })
            .attr("y1", function(d) { return height*d.y1; })
            .attr("x2", function(d) { return width*d.x2; })
            .attr("y2", function(d) { return height*d.y2; })
            .style("stroke", function(d) {
                return d3.hsl(100,d.color,d.color).toString();
            })
            .style("stroke-width", 0.0);

        // Specify what to do for changing attributes. Here, only the
        // stroke-width is updated and all other attributes are
        // assumed to stay constant after the element entered.
        // The duration the animation takes to update the value is given
        // with duration() in milliseconds.
        lines.transition()
            .duration(250)
            .style("stroke-width", function(d) { return width*d.width; });

        // Specify what to do when an element is missing in the new
        // data. Here, just remove it.
        lines.exit()
            .remove();

    };
}


// ------------ now start a d3.js plot ------------

// Initialize the VizPlot for our canvas element.
var viz_plot = VizPlot('canvas_plot');

// Listen for the 'update' signal from the backend. This is the only
// Databench specific code here.
databench.on('update_plot', function(json) {
    viz_plot(json);
});

// Implement a basic plot with d3.js.
function VizPlot(id) {
    // Initialize the d3 selector for the svg element and
    // obtain height and width.
    var svg = d3.select('#'+id),
        height = parseFloat(svg.attr('height')),
        width = parseFloat(svg.attr('width'));

    // Specify margins of the plot within the svg element in pixels.
    var margin = {'left': 40, 'right': 20, 'top': 20, 'bottom': 20}

    // Setup scales. 'domain()' specifies the range of the variables is in the
    // data and 'range()' specifies the range of the coordinate on the
    // screen in pixels. The funcitons 'x' and 'y' are a variable
    // transformation from input data to pixels.
    //
    // Note that the range for x is 20 to 280 pixels. The range for y is
    // 280 to 20 pixels with the larger number first. This is because the
    // number of pixels are counted from the top of the SVG, but we want our
    // y axis to start at the bottom.
    var x = d3.scale.linear()
                .domain([0, 5])
                .range([margin.left, width-margin.right]);
    var y = d3.scale.linear()
                .domain([0, 1.5])
                .range([height-margin.bottom, margin.top]);
    // Now we are just going to test the variable transformations. The
    // output will appear in the browser JavaScript console, but also in
    // the log window in this analysis.
    console.log('Testing the transformations x() and y(). Output in pixels:');
    console.log(x(0));
    console.log(x(2));
    console.log(x(4));
    console.log(y(0));
    console.log(y(0.5));
    console.log(y(1.0));

    // Elements inside of SVG are drawn in the order they are added. Below
    // we are going to add the axes, but we want the axes to stay in front
    // of the content of the plot. So technically, we need to add the
    // content of the plot (the bars of the histogram) now and only then we
    // can add the axes. We cannot add the content now, but we can add a
    // group 'g' here for the content and later we will not draw the bars
    // into 'svg' but into 'g'.
    var plot_content = svg.append('g');

    // The x-axis, is effectively a visual representation of the
    // transformation defined with x(). So d3 has an 'axis()' function
    // packaged that takes a scale and turns it into a drawable element:
    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(5);
    // Draw the x-axis. The y-position for drawing an x-axis is always 0.
    // So one has to apply a group element 'g' first whose coordinates are
    // shifted such that y=0 is where we want to draw the x-axis. We can
    // either use 'height-margin.bottom' as the position in pixels, or
    // we can use the transformation y(0) to get the same result, but in a
    // cleaner way.
    svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,'+y(0)+')')
        .call(xAxis);
    // And the same for the y-axis:
    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");
    svg.append('g')
        .attr('class', 'y axis')
        .attr('transform', 'translate('+x(0)+',0)')
        .call(yAxis);

    // Return the function that is used to update the data
    // of what is plotted. The data 'json' has to be an array/list numbers.
    // For example: [0.4, 0.5, 0.3, 0.2, 0.1]
    //
    // Please see the 'basic d3.js' example above for comments on the data
    // flow. Here, only the new parts are commented.
    return function(json) {
        lines = plot_content.selectAll(".line").data(json);

        // The x-coordinates are derived from the index of the data element.
        // So for any attribute where the value is dynamically calculated
        // with a function, the arguments d and i of the function are the
        // element d of the data array and the index i. For the histogram,
        // drawing the box for x=[0,1) is done with a line centered at 0.5.
        // So in general, we take the index plus 0.5 and transform it into
        // pixels: x(i+0.5).
        //
        // The width of that line in pixels is calculated by the position
        // in pixels of at x=1 minus x=0: x(1)-x(0).
        lines.enter()
            .append("svg:line")
            .attr("class", "line")
            .attr("x1", function(d, i) { return x(i+0.5); })
            .attr("y1", y(0.0))
            .attr("x2", function(d, i) { return x(i+0.5); })
            .attr("y2", function(d) { return y(d); })
            .style("stroke", "#55aa55")
            .style("stroke-width", function(d) { return x(1)-x(0); });

        lines.transition()
            .duration(250)
            .attr("y2", function(d) { return y(d); });

        lines.exit()
            .remove();

    };
}
</script>
{% endblock footerscripts %}
