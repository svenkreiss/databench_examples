<!-- This is an HTML file that gets processed by Jinja2
(http://jinja.pocoo.org/docs/dev/). Jinja2 block commands are included in
curly braces and percent signs and inline commands in double angular brackets.
Everything outside these commands is just plain HTML. -->
{% from 'macros.html' import include_md %}
{% extends "base.html" %}


<!-- CHANGEME. This sets the content of the HTML <title> element. -->
{% block title %}Tutorial{% endblock %}



{% block content %}
<!-- The description of the analysis is in README.md. The macro include_md()
pulls that description in and converts it to html to be shown also here. -->
[[ include_md('tutorial/README.md') ]]

<hr />
<!-- CHANGEME. Put your analysis HTML here. -->
<h3>Generic UI Elements</h3>
{% filter markdown %}
Below are the _slider_ and _button_ as generic UI elements as demonstrated in
the first part of the tutorial. They are layouted using the grid systems of
[Twitter Bootstrap 3](http://getbootstrap.com/css/#grid).
{% endfilter %}
<div class="row">
    <div class="col-md-3">
        <label for="sleep_duration">Duration of sleep</label>
        <input type="range" name="sleep_duration" min="1" max="5" step="1" value="3" />
    </div>
    <div class="col-md-9">
        <button class="btn btn-primary" data-signal-name="run">Run</button>
    </div>
</div>

<br /><br />
<h3>Matplotlib and Basic d3.js</h3>
{% filter markdown %}
This part shows the output of the _Matplotlib_ (left) and the
_Basic d3.js_ (right) part of the tutorial. The output is generated
when you click _Run_ above.
{% endfilter %}
<div class="row">
    <div class="col-md-6">
        <div id="mpld3canvas"></div>
    </div>
    <div class="col-md-6">
        <svg id="canvas" width="300" height="300" />
    </div>
</div>

<hr />
<!-- This log output below is just nice to have when starting to design an
analysis. Feel free to just delete the line below now or later. -->
<pre id="log"></pre>
{% endblock content %}



{% block footerscripts %}
<script>
    // Initialize Databench's frontend library.
	var databench = Databench();

    // CHANGEME. Customize the code below.
    // Initialize the VizLogic for our canvas element.
var my_viz = VizLogic('canvas');

// Listen for the 'update' signal from the backend. This is the only
// Databench specific code here.
databench.on('update', function(json) {
    my_viz(json);
});

// Implement the drawing with d3.js.
function VizLogic(id) {
    // Initialize the d3 selector for the svg element and
    // obtain height and width.
    var svg = d3.select('#'+id),
        height = parseFloat(svg.attr('height')),
        width = parseFloat(svg.attr('width'));

    // Return the function that is used to update the data
    // of what is plotted. The data 'json' has to be of the form:
    // [
    //     {'id': 1, 'x1': 0.1, 'y1': 0.1, 'x2': 0.8, 'y2': 0.1,
    //      'width': 0.05, 'color': 0.5},
    //     {'id': 2, 'x1': 0.1, 'y1': 0.3, 'x2': 0.8, 'y2': 0.3,
    //      'width': 0.05, 'color': 0.7},
    //     {'id': 3, 'x1': 0.1, 'y1': 0.5, 'x2': 0.8, 'y2': 0.5,
    //      'width': 0.05, 'color': 0.9},
    //     ...
    // ]
    return function(json) {
        // The new 'json' data (has to be an array) is compared to the
        // existing elements with the class 'line'. By default, d3.js
        // uses the element index in the array as the key to associate
        // elements from previous data calls with the new ones. This
        // breaks when data is inserted in the middle of arrays.
        // Therefore, a function that returns the 'key' can be specified
        // as the second argument to data(). Here, the key is the element
        // with the name 'id'.
        lines = svg.selectAll(".line").data(json, function(d) { return d.id; });

        // Specify what happens how to initialize a new element. Note
        // that lines.transition() is also applied to elements that just
        // entered. Specify the initial attributes here (like width 0.0)
        // and then set the actual attributes it should animate to in
        // transition() below.
        //
        // Every attribute is given either a value (like for stroke-width)
        // or the value is obtained by calling a function with the data
        // element, in this example it could be
        //    {'id': 1, 'x1': 0.1, 'y1': 0.1, 'x2': 0.8, 'y2': 0.1,
        //     'width': 0.05, 'color': 0.1}
        // and the function calculates the value. Below, the functions
        // scale x1, y1, x2 and y2 from a range of [0,1] to [0,width]
        // and [0,height] in pixels and convert a color in the range
        // [0,1] to a color of the form #123456 by using the d3.hsl()
        // function.
        lines.enter()
            .append("svg:line")
            .attr("class", "line")
            .attr("x1", function(d) { return width*d.x1; })
            .attr("y1", function(d) { return height*d.y1; })
            .attr("x2", function(d) { return width*d.x2; })
            .attr("y2", function(d) { return height*d.y2; })
            .style("stroke", function(d) {
                return d3.hsl(100,d.color,d.color).toString();
            })
            .style("stroke-width", 0.0);

        // Specify what to do for changing attributes. Here, only the
        // stroke-width is updated and all other attributes are
        // assumed to stay constant after the element entered.
        // The duration the animation takes to update the value is given
        // with duration() in milliseconds.
        lines.transition()
            .duration(250)
            .style("stroke-width", function(d) { return width*d.width; });

        // Specify what to do when an element is missing in the new
        // data. Here, just remove it.
        lines.exit()
            .remove();

    };
}
</script>
{% endblock footerscripts %}
